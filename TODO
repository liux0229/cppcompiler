= High level design notes and TODO =

Language features
* Point of declaration (after declarator but before initializer)

* Clean-up of name lookup
** What does it mean to lookup a namespace-name or an enum name? Should I do
   a lookup of all names, then pick up namespace names, etc. in the final set
   or the lookup is restrictive from the get-go?

* Every expression should have two types of knowledge associated with it
** How to generate the corresponding runtime code (internal representation which
   is directly translatable to machine code)
** How to evaluate the expression at compile time (operands must be
   constant-expression)

* Function parameter type declarations

* Think more about context-free / context-dependent parsing as it relates to
  C++ parsing. Is C++ parsing really context-depedent parsing - should be,
  for example, prefer function declaration as opposed to object definition.

Infrastructure support
* Better reporting of source file location upon error
** Can consider whether tackle this before or after PA10

* Literal design clean-up (on the high level, a Literal consits of a type and
  value). Every value in the program (either compile time value or runtime 
  value) should have a type.
** Simplify the current design / implementation if we can
** Consider migrate PostToken to use the Literal design (and rename PostToken to
   Token)
** Since PA9 uses PostToken, make sense to do this clean-up before and during
   PA9

* What's semantic different about block-declarations compared to other
  declarations - that only a block can contain them?

= PA9 =
* Error user-defined literal and C++ keywords (produce 1 exit code)
* Bit-wise op vs. floating point?

= Cases to think about =

final/cases/103-constexpr.cpp: type of constexpr arrays
